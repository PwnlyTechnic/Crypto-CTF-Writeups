from MTRecover import MT19937Recover
from Crypto.Util.number import *
from Crypto.PublicKey import ElGamal
from cryptography.hazmat.primitives.asymmetric.utils import encode_dss_signature
from cryptography.hazmat.primitives.asymmetric.dsa import *
import random
import struct
import requests
import json
import hashlib

local = "http://localhost:5000/"
remote = "http://crypto.chal.csaw.io:1009/"

def chunk(inputstr, size):
    return [inputstr[i:i+size] for i in range(0, len(inputstr), size)]

def mersennebreaker(output_list):
    assert len(output_list) > 624
    mtr = MT19937Recover()
    r2 = mtr.go(output_list)
    return r2

def _forgotpassword():
    req = requests.get(remote + "forgotpass")
    return str(req.text[33:]).decode("hex")

def _get_publickey():
    req = requests.get(remote + "public_key")
    return (json.loads(req.text)['p'], json.loads(req.text)['q'], json.loads(req.text)['y'], json.loads(req.text)['g'])

def _get_sign(data):
    req = requests.get(remote + "sign/" + data)
    return (json.loads(req.text)['r'], json.loads(req.text)['s'])

def _get_secretkey(r, s, q, h, r2):
    k = r2.randrange(2, q)
    rinv = inverse(r, q)
    x = (rinv * (s*k - h)) % q
    return x

def _get_challenge():
    req = requests.get(remote + "challenge")
    return req.text

def _sign(data, g, k, p, q, x):
    kinv = inverse(k, q)
    r = pow(g, k, p) % q
    h = bytes_to_long(hashlib.sha256(data).digest())
    s = (kinv * (h + r*x)) % q
    return (r, s)


outputs = []
for i in range(313):
    randnum = _forgotpassword()
    chunks = chunk(randnum, 4)[::-1]
    for j in range(len(chunks)):
        chunks[j] = bytes_to_long(chunks[j])
    outputs.extend(chunks)
    print "mersenne breaking iterator value: ", i

r2 = mersennebreaker(outputs)
assert r2.getrandbits(64) == bytes_to_long(_forgotpassword())

# Getting public key parameter values
p, q, y, g = _get_publickey()

# Signing some data
r, s = _get_sign("testmsg")
h = bytes_to_long(hashlib.sha1("testmsg").digest())
# Getting the value of secret key
x = _get_secretkey(r, s, q, h, r2)

assert y == pow(g, x, p)

# Get string to be signed
sign_string = _get_challenge()

print "Sign string: ", sign_string
print "p: ", p
print "secret key: ", x

sig = _sign(sign_string, g, 13, p, q, x)
r1, s1 = sig
signa = encode_dss_signature(r1, s1).encode("hex")

req = requests.post(remote + "capture",data={"signature":signa, "challenge":sign_string})
print req.text
